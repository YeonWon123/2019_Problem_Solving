#include <iostream>
using namespace std;

int K, N;
int lan[10000];

int main() {

	// 랜선의 길이를 계속 바꿔가면서 필요한 랜선의 갯수와 비교해 줄이거나 늘리거나 한다.
	// 현재 길이가 x일때 얻을수 있는 랜선이 y이고 
	// 이게 내가 필요한 랜선의 갯수보다 작다면 x의 길이를 줄이고 크거나 같다면 x의 길이를 늘리는 방식이다.
	
	//------------------------------------------------------------------------------------------------//

	// K개의 랜선을 적절하게 같은 길이로 잘라 N개의 랜선을 만들어야 하는데,
	// N개를 만들지 못하는 경우는 없다고 주어졌다.
	
    // 길이는 모두 정수 값이므로, 나무 자르는 문제와 같이 가능한 모든 길이를 시도해 보면 된다.
	// 마찬가지로 이분 탐색으로 범위를 줄여나갈 수 있고, 현재 시도 중인 길이에 대해 두 가지 케이스가 발생한다.

	// 1. 잘라봐도 N개를 만들지 못할 때
	// 더 긴 길이로 잘라봐야 만들지 못할것이 자명하므로 왼쪽 부분으로 좁혀서 탐색한다.
	// 2. N개를 만들 수 있을 때
	// 더 긴 길이를 시도해 봐야 하므로 오른쪽 부분으로 좁혀서 탐색한다.

	// 범위를 좁히다 보면 하한선과 상한선이 엇나가게 될 것이고, 중간에 기록해둔 값들 중 최대 길이가 정답이 된다.

	//------------------------------------------------------------------------------------------------//

	// 1. 이분 탐색 같은 경우는 답을 유추해서 문제에 대입 정답을 도출하는 경우가 많다.

	// 2. 이 문제도 길이에 대한 정답을 도출해서 2분 탐색으로 끊임없이 탐색해서 결론을 도출하는 것이다.
	// 즉 길이를 정하고 그 길이에 대한 값으로 랜선을 잘랐을시
	// 그 개수가 원하는 개수보다 크거나 같으면 left를 mid + 1 로 반대면 right를 mid - 1로 바꾸는 것이다.

	// 3. 여기서 범위가 int로 하니까 오류가 났다.그래서 long long 으로 해줘서 정답을 도출 하였다.
	
	cin >> K >> N;

	long long start = 1;
	long long end = 0;
	for (int i = 0; i < K; i++) {
		cin >> lan[i];
		if (end < lan[i])
			end = lan[i];
	}

	long long ans = 0;
	long long mid;
	while (start <= end) {
		int temp = 0;
		mid = (start + end) / 2;
		for (int i = 0; i < K; i++) {
			temp += lan[i] / mid;
		}

		if (temp >= N) {
			start = mid + 1;
			if (mid > ans) {
				ans = mid;
			}
		}
		else {
			end = mid - 1;
		}
	}
	cout << ans;
	return 0;
}