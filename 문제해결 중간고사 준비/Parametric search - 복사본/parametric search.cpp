#include <iostream>
using namespace std;

int M, N;
int trees[1000001];

int main() {
	
	// 절단기의 높이를 조절하면서 내가 필요한 나무 길이보다 더 얻을 경우 절단기 높이를 줄이고
	// 나무의 길이가 짧을 경우 절단기의 높이를 높이는 방식으로 진행한다.
	
	//-----------------------------------------------------------------------------------//
	
	// 시도해 볼 수 있는 높이는 모두 정수다.
	// 따라서 모든 가능한 정수에 대해서 시도해보면,
	// M보다 크거나 같은 결과가 나오는 높이들을 파악할 수 있고,
	// 그 중 가장 큰 정수를 찾으면 된다.
	
	// 하지만 모든 정수를 시도해 볼 필요는 없다.
	// 만약 300의 높이로 시도해 보았을 때, M보다 작은 결과가 나온다면, 300보다 작은 높이로 시도했을 때도 당연히 실패할 것이기 때문이다.
	// 따라서 가능한 결과들은 한 구간으로만 나올 것이다.
	// 우리가 할 것은 그 구간을 빠르게 찾는 것이다.
	// 이진 탐색으로 빠르게 구간을 찾을 수 있다.
	// 1/2 씩 구간을 줄여나가는 방법으로, n개의 수를 로그시간에 탐색할 수 있다.

	// 정수의 범위는 1부터 가장 높은 나무의 높이 까지다.
	// 주어진 나무 높이의 합이 M보다 크다는 조건 때문에 1을 계산해볼 필요가 없다.
			   
	// 가장 큰 높이로 자르면 당연히 합이 0일 것이므로 계산해볼 필요가 없다.
			   		 	  
	// 이제부터 중간값으로 구간을 줄여보자.
	// 중간 높이로 자르고 나면 두 가지 경우가 생긴다.

	// 1. 잘린 나무의 합이 M보다 작을 경우
	// 현재 높이보다 낮은 높이로 시도해 보아야 한다.왼쪽 구간으로 변경

	// 2. 잘린 나무의 합이 M보다 작거나 클 경우
	// 현재 높이보다 높은 높이로 시도해 볼 수 있다.오른쪽 구간으로 변경

	// 이를 반복하다보면 구간의 제일 큰 정수 값을 알 수 있다.
	
	cin >> N >> M;

	long long start = 0;
	long long end = 0;
	for (int i = 0; i < N; i++) {
		cin >> trees[i];
		if (end < trees[i])
			end = trees[i];
	}

	long long ans = 0;
	long long mid;
	while (start <= end) {
		long temp = 0;
		mid = (start + end) / 2;
		for (int i = 0; i < N; i++) {
			// 음수일때 조심
			if (trees[i] - mid >= 0)
				temp += trees[i] - mid;
		}

		if (temp >= M) {
			start = mid + 1;
			if (mid > ans) {
				ans = mid;
			}
		}
		else {
			end = mid - 1;
		}
	}
	cout << ans;
	return 0;
}