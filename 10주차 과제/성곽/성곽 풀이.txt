// 움직일 수 있는가?
 -> 벽이 없으면 됨

* bfs 이용

for (int i = 0; i < 4; i++) {
	int nx = x + dx[i];
	int ny = y + dy[i];

	if (제대로 된 범위 내라면) {
		if (아직 방문하지 않은 정점이라면) {
			visit[nx][ny] = true;
			Q.push(make_pair(nx, ny));
		}
	}
}


11 & 1 = 1011 & 0001 = 0001 -> 벽 있음
11 & 2 = 1011 & 0010 = 0010 -> 벽 있음
11 & 4 = 1011 & 0100 = 0000 -> 벽 없음!
11 & 8 = 1011 & 1000 = 1000 -> 벽 있음

이를 적용하면

int Wall = 1;
for (int i = 0; i < 4; i++) {
	if (MAP[x][y] & Wall != Wall) {
		int nx = x + dx[i];
		int ny = y + dy[i];
		
		if (제대로 된 범위 내라면) {
			if (아직 방문하지 않은 정점이라면) {
				visit[nx][ny] = true;
				Q.push(make_pair(nx,ny));
			}
		}
	}
	Wall = Wall * 2; // 1,2,4,8
}

1번의 경우는, bfs를 호출하는 횟수, 방문하지 않는 정점에 대해서만 bfs를 호출할 것
2번의 경우, 방의 개수를 counts할 변수 하나만 두고, 방문할 수 있는 정점이라서 Q에 push될 때마다 그 변수값을 ++ 시켜주는 연산을 함
3번의 경우, 존재하는 모든 벽을 하나씩 다 없애줌
11 & 1 = 1이면 11 - 1 후 시도해봄 -> 벽 다시 생성
11 & 2 = 2이면 11 - 2 후 시도해봄 -> 벽 다시 생성
...
